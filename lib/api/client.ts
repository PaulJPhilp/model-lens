// Generated API client types from OpenAPI specification
// Do not edit this file manually - it will be overwritten

export interface Model {
	id: string
	name: string
	provider: string
	contextWindow: number
	maxOutputTokens: number
	inputCost: number
	outputCost: number
	cacheReadCost: number
	cacheWriteCost: number
	modalities: "text" | "image" | "audio" | "video" | "file"[]
	capabilities:
		| "tools"
		| "reasoning"
		| "knowledge"
		| "generation"
		| "conversation"[]
	releaseDate: string
	lastUpdated: string
	knowledge: string
	openWeights: boolean
	supportsTemperature: boolean
	supportsAttachments: boolean
	new: boolean
}

export interface ResponseMetadata {
	duration?: number
	timestamp?: string
	totalModels?: number
}

export interface ErrorResponse {
	error?: string
	field?: string
	message?: string
}

// API Response wrapper
export interface ApiResponse<T> {
	data: T
	metadata: ResponseMetadata
}

// API Error response
export interface ApiError {
	error: string
	field?: string
	message?: string
}

// API Client class
export class ModelLensApiClient {
	private baseUrl: string

	constructor(
		baseUrl: string = typeof window !== "undefined"
			? window.location.origin
			: "http://localhost:3000",
	) {
		this.baseUrl = baseUrl
	}

	private async request<T>(
		endpoint: string,
		options: RequestInit = {},
	): Promise<ApiResponse<T>> {
		const url = `${this.baseUrl}${endpoint}`

		const response = await fetch(url, {
			headers: {
				"Content-Type": "application/json",
				...options.headers,
			},
			...options,
		})

		if (!response.ok) {
			const error: ApiError = await response.json()
			throw new Error(error.error || `HTTP ${response.status}`)
		}

		return response.json()
	}

	/**
	 * Get all AI models with optional filtering
	 */
	async getModels(params?: {
		limit?: number
		provider?: string
	}): Promise<ApiResponse<{ models: Model[] }>> {
		const searchParams = new URLSearchParams()
		if (params?.limit) searchParams.set("limit", params.limit.toString())
		if (params?.provider) searchParams.set("provider", params.provider)

		const queryString = searchParams.toString()
		const endpoint = queryString ? `/api/models?${queryString}` : "/api/models"

		return this.request<{ models: Model[] }>(endpoint)
	}

	/**
	 * Get a specific model by ID
	 */
	async getModelById(id: string): Promise<ApiResponse<{ model: Model }>> {
		return this.request<{ model: Model }>(`/api/models/${id}`)
	}

	/**
	 * Trigger model data synchronization (admin only)
	 */
	async syncModels(token: string): Promise<
		ApiResponse<{
			message: string
			stats: {
				totalModels: number
				newModels: number
				updatedModels: number
				failedFetches: number
			}
		}>
	> {
		return this.request<{
			message: string
			stats: {
				totalModels: number
				newModels: number
				updatedModels: number
				failedFetches: number
			}
		}>("/api/admin/sync-models", {
			method: "POST",
			headers: {
				Authorization: `Bearer ${token}`,
			},
		})
	}
}

// Default client instance
export const apiClient = new ModelLensApiClient()

// React hook for using the API client
export function useModelLensApi() {
	return {
		getModels: apiClient.getModels.bind(apiClient),
		getModelById: apiClient.getModelById.bind(apiClient),
		syncModels: apiClient.syncModels.bind(apiClient),
	}
}
