#!/usr/bin/env bun

/**
 * Generate TypeScript client types from OpenAPI specification
 * This script reads the OpenAPI YAML and generates TypeScript types
 * for API requests and responses
 */

import { readFileSync, writeFileSync } from "node:fs"
import { join } from "node:path"
import { parse } from "yaml"

interface OpenAPISchema {
	openapi: string
	info: {
		title: string
		version: string
		description: string
	}
	paths: Record<string, unknown>
	components: {
		schemas: Record<string, unknown>
	}
}

function generateTypeFromSchema(schema: unknown, name: string): string {
	if (!schema || typeof schema !== "object") {
		return "any"
	}

	const schemaObj = schema as Record<string, unknown>
	if (schemaObj.type === "object" && schemaObj.properties) {
		const properties = Object.entries(
			schemaObj.properties as Record<string, unknown>,
		)
			.map(([propName, propSchema]: [string, unknown]) => {
				const type = generateTypeFromSchema(propSchema, propName)
				const required = (schemaObj.required as string[])?.includes(propName)
					? ""
					: "?"
				return `  ${propName}${required}: ${type};`
			})
			.join("\n")

		return `{\n${properties}\n}`
	}

	if (schemaObj.type === "array" && schemaObj.items) {
		const itemType = generateTypeFromSchema(schemaObj.items, name)
		return `${itemType}[]`
	}

	if (schemaObj.enum) {
		return (schemaObj.enum as unknown[])
			.map((val: unknown) => `"${val}"`)
			.join(" | ")
	}

	switch (schemaObj.type) {
		case "string":
			return "string"
		case "integer":
		case "number":
			return "number"
		case "boolean":
			return "boolean"
		case "object":
			return "Record<string, any>"
		default:
			return "any"
	}
}

function generateApiClient(): void {
	console.log("üîß Generating API client types from OpenAPI specification...")

	try {
		// Read OpenAPI spec
		const openApiPath = join(process.cwd(), "docs", "api", "openapi.yaml")
		const openApiContent = readFileSync(openApiPath, "utf-8")
		const spec: OpenAPISchema = parse(openApiContent)

		// Generate types for schemas
		const schemaTypes = Object.entries(spec.components.schemas)
			.map(([name, schema]) => {
				const typeDefinition = generateTypeFromSchema(schema, name)
				return `export interface ${name} ${typeDefinition}`
			})
			.join("\n\n")

		// Generate API client class
		const apiClientCode = `// Generated API client types from OpenAPI specification
// Do not edit this file manually - it will be overwritten

${schemaTypes}

// API Response wrapper
export interface ApiResponse<T> {
  data: T;
  metadata: ResponseMetadata;
}

// API Error response
export interface ApiError {
  error: string;
  field?: string;
  message?: string;
}

// API Client class
export class ModelLensApiClient {
  private baseUrl: string;

  constructor(baseUrl: string = typeof window !== 'undefined' ? window.location.origin : 'http://localhost:3000') {
    this.baseUrl = baseUrl;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = \`\${this.baseUrl}\${endpoint}\`;
    
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    });

    if (!response.ok) {
      const error: ApiError = await response.json();
      throw new Error(error.error || \`HTTP \${response.status}\`);
    }

    return response.json();
  }

  /**
   * Get all AI models with optional filtering
   */
  async getModels(params?: {
    limit?: number;
    provider?: string;
  }): Promise<ApiResponse<{ models: Model[] }>> {
    const searchParams = new URLSearchParams();
    if (params?.limit) searchParams.set('limit', params.limit.toString());
    if (params?.provider) searchParams.set('provider', params.provider);

    const queryString = searchParams.toString();
    const endpoint = queryString ? \`/api/models?\${queryString}\` : '/api/models';
    
    return this.request<{ models: Model[] }>(endpoint);
  }

  /**
   * Get a specific model by ID
   */
  async getModelById(id: string): Promise<ApiResponse<{ model: Model }>> {
    return this.request<{ model: Model }>(\`/api/models/\${id}\`);
  }

  /**
   * Trigger model data synchronization (admin only)
   */
  async syncModels(token: string): Promise<ApiResponse<{
    message: string;
    stats: {
      totalModels: number;
      newModels: number;
      updatedModels: number;
      failedFetches: number;
    };
  }>> {
    return this.request<{
      message: string;
      stats: {
        totalModels: number;
        newModels: number;
        updatedModels: number;
        failedFetches: number;
      };
    }>('/api/admin/sync-models', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${token}\`,
      },
    });
  }
}

// Default client instance
export const apiClient = new ModelLensApiClient();

// React hook for using the API client
export function useModelLensApi() {
  return {
    getModels: apiClient.getModels.bind(apiClient),
    getModelById: apiClient.getModelById.bind(apiClient),
    syncModels: apiClient.syncModels.bind(apiClient),
  };
}
`

		// Write generated types
		const outputPath = join(process.cwd(), "lib", "api", "client.ts")
		writeFileSync(outputPath, apiClientCode, "utf-8")

		console.log("‚úÖ API client types generated successfully!")
		console.log(`üìÅ Output: ${outputPath}`)
		console.log(
			`üìä Generated ${
				Object.keys(spec.components.schemas).length
			} type definitions`,
		)
	} catch (error) {
		console.error("‚ùå Failed to generate API client types:", error)
		process.exit(1)
	}
}

// Run the generator
if (import.meta.main) {
	generateApiClient()
}

export { generateApiClient }
